{
  "magic": "E!vIA5L86J2I",
  "timestamp": "2024-12-22T00:17:35.645987+00:00",
  "repo": "marten-seemann/draft-seemann-quic-nat-traversal",
  "labels": [
    {
      "name": "bug",
      "description": "Something isn't working",
      "color": "d73a4a"
    },
    {
      "name": "documentation",
      "description": "Improvements or additions to documentation",
      "color": "0075ca"
    },
    {
      "name": "duplicate",
      "description": "This issue or pull request already exists",
      "color": "cfd3d7"
    },
    {
      "name": "enhancement",
      "description": "New feature or request",
      "color": "a2eeef"
    },
    {
      "name": "good first issue",
      "description": "Good for newcomers",
      "color": "7057ff"
    },
    {
      "name": "help wanted",
      "description": "Extra attention is needed",
      "color": "008672"
    },
    {
      "name": "invalid",
      "description": "This doesn't seem right",
      "color": "e4e669"
    },
    {
      "name": "question",
      "description": "Further information is requested",
      "color": "d876e3"
    },
    {
      "name": "wontfix",
      "description": "This will not be worked on",
      "color": "ffffff"
    }
  ],
  "issues": [
    {
      "number": 1,
      "id": "I_kwDOJ5p67M5rLg3F",
      "title": "How much of ICE do we want to specify?",
      "url": "https://github.com/marten-seemann/draft-seemann-quic-nat-traversal/issues/1",
      "state": "CLOSED",
      "author": "huitema",
      "authorAssociation": "NONE",
      "assignees": [],
      "labels": [],
      "body": "ICE is a rather complex protocol, but the underlying ideas are simple:\r\n\r\n- Assume an established channel over which the peer can coordinate\r\n- Endpoints are behind NAT. If they send a packet towards a destination IP and port, they often cannot predict the exact source IP and port.\r\n       - But with the help of STUN servers and possibly UPNP or NAT-PMP, try to predict the IP+port at which they can be reachable through the local set of NATs\r\n       - Of course this is guesswork.\r\n- Each endpoint communicates the set of plausible IP + port numbers pairs to the peer over the signalling channel\r\n- Each of the endpoints send a set of probes to these guessed port numbers\r\n     - Many of these probes will not make it, because of firewall rules such as only accepting incoming traffic on an IP and port if there was some outgoing traffic in the same direction, \r\n     - but the hope is that there will be that out of the set of packets sent by each endpoint, there will be at least one in which the guessing worked.\r\n- If one of the probe made it through, confirm that to the peer. There is now a workable peer-to-peer path.\r\n- In no probe arrives, then fall back to a proxy of some kind, for example using TURN.\r\n\r\nThere are additional complexities:\r\n\r\n- sending probes has side effects. For example, sending too many probes forces the local NAT to create as many mapping context, and some of these NAT only support a small set of simultaneous mapping. Thus, the strategy of sending 256 packets from each side and relying on the birthday paradox may not be the best.\r\n\r\n- sending list of IP addresses has privacy issues, especially when disclosing addresses behind the NAT, so consider using some substitute, e.g, a randomized Bonjour name.\r\n\r\n- tricking a peer to send a bunch of messages to random addresses can obviously be used in DOS attacks\r\n\r\nWhich means we do not have just one message, but rather 3 or 5:\r\n\r\n- An address message, \"here is my list of addresses\", sent over the signalling channel, which in our case could be a proxied QUIC connection. \r\n- A probe message, sent to one of the candidate peer address+port, which could be very similar to a PATH_CHALLENGE\r\n- A probe response, which could be very similar to a PATH_RESPONSE\r\n- Maybe an address response, as in \"I see your packet as coming from IP=A, Port=P\", by which the endpoint could learn how its own address is seen by the peer.\r\n- Maybe some synchronization message, as in \"try me now\", because the port opening only works well if both endpoints send their packets within a short interval.\r\n\r\nWe can debate whether the probing should use existing frames (e.g. PATH_CHALLENGE) or a new ICE frame,  but we would have to explain that these ICE frames are sent on the probed paths, just like path challenge.\r\n\r\nSince this is a rather complex issue, it might be simpler to start with the scenario in which there is an existing proxied connection between the two endpoints, and we are merely trying to migrate the traffic to a direct path.\r\n\r\n\r\n",
      "createdAt": "2023-07-11T06:10:41Z",
      "updatedAt": "2023-10-18T11:43:20Z",
      "closedAt": "2023-10-18T11:43:19Z",
      "comments": [
        {
          "author": "huitema",
          "authorAssociation": "NONE",
          "body": "NAT rebinding can happen at either end, and will break the \"peer-to-peer\" path. It might make sense to start from Multipath QUIC, with one path through the proxy and another for the peer-to-peer shortcut.\r\n\r\nMultipath is currently limited to establishment of new paths by the client. If peer-to-peer defines an Address Advertisement frame, the multipath-enabled server could use it to tell the client to establish another \"preferred\" path.",
          "createdAt": "2023-07-11T06:15:59Z",
          "updatedAt": "2023-07-11T06:15:59Z"
        },
        {
          "author": "marten-seemann",
          "authorAssociation": "OWNER",
          "body": "@huitema Are you suggesting to drop ICE entirely? I agree that ICE is quite complex, and I've spent a fair amount of time reading the RFCs, and I'm not sure I've fully understood it...\r\nHowever, I also don't want to reinvent the wheel. It seems like ICE already solves all the points you list in the first two lists of your post. Where do you see the simplification coming from when dropping ICE for our own home-grown protocol?\r\n\r\n---\r\n\r\n>  It might make sense to start from Multipath QUIC, with one path through the proxy and another for the peer-to-peer shortcut.\r\n\r\nThis definitely should work well with Multipath QUIC (that actually should be a design goal of this protocol), but I'd prefer to not make it a requirement, if we can avoid it. RFC 9000 allows keeping several paths alive, and endpoints could keep the proxied connection alive (by regularly sending probing packets) after they've migrated to a direct path. On the other hand, this is probably not what the proxy wants: It wants to free up resources as quickly as possible. How does ICE handle this?\r\n\r\n> NAT rebinding can happen at either end, and will break the \"peer-to-peer\" path. \r\n\r\nDo we have any numbers on how often NAT rebindings actually happen, and if they can be avoided by more aggressive keep-alives? Given the trouble endpoints have gone through to establish a hole-punched connections, it might be justified to invest more into keeping the NAT binding alive (e.g. send a PING frame at least every 5s or so). It would be nice if we could base this kind of recommendation on data though.",
          "createdAt": "2023-07-11T18:27:48Z",
          "updatedAt": "2023-07-11T18:27:48Z"
        },
        {
          "author": "huitema",
          "authorAssociation": "NONE",
          "body": "I think supporting both RFC9000 and Multipath is more complex than just doing multipath alone. I also think that starting from multipath allows for incremental development, such as, after having a multipath capable proxy connection. Maybe for example, test local discovery first, then traversal of IPv6 stateful firewall, then add discovery of NATed addresses.",
          "createdAt": "2023-07-12T05:27:12Z",
          "updatedAt": "2023-07-12T05:27:12Z"
        },
        {
          "author": "marten-seemann",
          "authorAssociation": "OWNER",
          "body": "https://github.com/marten-seemann/draft-seemann-quic-nat-traversal/pull/11 completely changed how this draft uses ICE. I believe this resolves this issue.",
          "createdAt": "2023-10-18T11:43:20Z",
          "updatedAt": "2023-10-18T11:43:20Z"
        }
      ]
    },
    {
      "number": 2,
      "id": "I_kwDOJ5p67M5r8Xxq",
      "title": "Citations in abstracts",
      "url": "https://github.com/marten-seemann/draft-seemann-quic-nat-traversal/issues/2",
      "state": "CLOSED",
      "author": "martinthomson",
      "authorAssociation": "NONE",
      "assignees": [],
      "labels": [],
      "body": "As a general rule (and due to the style guide), citations in abstracts are discouraged.  That is, you might say \"RFC 9000\", but not use \"[RFC9000]\".",
      "createdAt": "2023-07-19T01:45:27Z",
      "updatedAt": "2023-10-15T05:09:52Z",
      "closedAt": "2023-10-15T05:09:52Z",
      "comments": []
    },
    {
      "number": 3,
      "id": "I_kwDOJ5p67M5sUIRl",
      "title": "think carefully about NAT rebindings on the server side",
      "url": "https://github.com/marten-seemann/draft-seemann-quic-nat-traversal/issues/3",
      "state": "OPEN",
      "author": "marten-seemann",
      "authorAssociation": "OWNER",
      "assignees": [],
      "labels": [],
      "body": "Since the server is now also (potentially) a p2p node, it might be behind a NAT, and therefore might experience NAT rebindings. We need to define how a client should react to that.",
      "createdAt": "2023-07-23T17:35:39Z",
      "updatedAt": "2023-07-23T17:35:39Z",
      "closedAt": null,
      "comments": []
    },
    {
      "number": 4,
      "id": "I_kwDOJ5p67M5sUIaa",
      "title": "mention QUIC Multipath",
      "url": "https://github.com/marten-seemann/draft-seemann-quic-nat-traversal/issues/4",
      "state": "CLOSED",
      "author": "marten-seemann",
      "authorAssociation": "OWNER",
      "assignees": [],
      "labels": [],
      "body": "Not mentioning QUIC Multipath was an oversight and has led to a fair bit of discussion.\r\n\r\nCopy-pasting from an email I sent to the list:\r\n\r\nI'd like this extension to work well with QUIC Multipath, and I don't see anything that would prevent that. However, I don't think it needs anything multipath-specific, and can run on top of a RFC 9000 stack just as well.\r\n\r\nIn specific:\r\n1. RFC 9000 already allows a client to simultaneously probe an arbitrary number of paths, and to keep them alive (by sending probing packets). The only thing that multipath adds here is the capability to send / receive on multiple paths at the same time, but a NAT won't even be able to distinguish between these scenarios.\r\n1. Multipath doesn't allow the server to initiate a new path: as in RFC 9000, path initiation is solely the client's responsibility. A NAT traversal solution will need to define a way for the server to send a hole punching packet either way.\r\n\r\nRelated: #1.",
      "createdAt": "2023-07-23T17:37:42Z",
      "updatedAt": "2023-10-18T10:57:59Z",
      "closedAt": "2023-10-18T10:57:59Z",
      "comments": []
    },
    {
      "number": 5,
      "id": "I_kwDOJ5p67M5sUIk0",
      "title": "put the QUIC layer in control of selecting the path (mode 3)",
      "url": "https://github.com/marten-seemann/draft-seemann-quic-nat-traversal/issues/5",
      "state": "CLOSED",
      "author": "marten-seemann",
      "authorAssociation": "OWNER",
      "assignees": [],
      "labels": [],
      "body": "Currently the draft says:\r\n> Upon the completion of path validation, the QUIC stack passes the result (successful or failed) back to the ICE stack. The ICE stack then nominates an address pair. The client SHOULD then migrate the QUIC connection to this path in a timely manner.\r\n\r\nAs pointed out by @martinthomson on the list, we should put the QUIC layer in charge of selecting a path when using mode 3. A QUIC stack (multipath or not) will necessarily have some path selection / scheduling logic. We don't need to hand off the decision to ICE.",
      "createdAt": "2023-07-23T17:40:02Z",
      "updatedAt": "2023-10-15T07:34:54Z",
      "closedAt": "2023-10-15T07:34:53Z",
      "comments": []
    },
    {
      "number": 6,
      "id": "I_kwDOJ5p67M5sjgVT",
      "title": "consider removing mode 2",
      "url": "https://github.com/marten-seemann/draft-seemann-quic-nat-traversal/issues/6",
      "state": "CLOSED",
      "author": "marten-seemann",
      "authorAssociation": "OWNER",
      "assignees": [],
      "labels": [],
      "body": "Mode 2 has been helpful to think about how to go from 1 to 3, but there might be limited value in defining it.",
      "createdAt": "2023-07-25T22:16:01Z",
      "updatedAt": "2023-10-15T07:34:54Z",
      "closedAt": "2023-10-15T07:34:54Z",
      "comments": []
    },
    {
      "number": 7,
      "id": "I_kwDOJ5p67M5s6sG9",
      "title": "consider moving ICE address matching / time ordering logic into this draft",
      "url": "https://github.com/marten-seemann/draft-seemann-quic-nat-traversal/issues/7",
      "state": "CLOSED",
      "author": "marten-seemann",
      "authorAssociation": "OWNER",
      "assignees": [],
      "labels": [],
      "body": "Then we wouldn't need a dependency on ICE.\r\n\r\nApparently ICE was designed with the assumption that the application might have several connections to the same endpoint at the same time, e.g. to demultiplex audio and video. Obviously, this isn't needed when using a multiplexed transport, and might lead to some simplifications.",
      "createdAt": "2023-07-29T05:17:36Z",
      "updatedAt": "2023-10-15T07:34:54Z",
      "closedAt": "2023-10-15T07:34:54Z",
      "comments": []
    },
    {
      "number": 8,
      "id": "I_kwDOJ5p67M5s6uBX",
      "title": "evaluate bandwidth requirements for probing multiple paths",
      "url": "https://github.com/marten-seemann/draft-seemann-quic-nat-traversal/issues/8",
      "state": "OPEN",
      "author": "marten-seemann",
      "authorAssociation": "OWNER",
      "assignees": [],
      "labels": [],
      "body": "When presenting this proposal in AVTCore at IETF 117, some concern was voiced that probing using RFC 9000's path probing mechanism consumes more bandwidth than probing using STUN packets. While that's true, it's not clear if that poses a problem in 2023. We should evaluate and at the very least add these considerations to the draft.",
      "createdAt": "2023-07-29T05:44:39Z",
      "updatedAt": "2023-10-15T07:29:57Z",
      "closedAt": null,
      "comments": [
        {
          "author": "marten-seemann",
          "authorAssociation": "OWNER",
          "body": "I'm still not convinced that bandwidth is a major concern here. Especially for video applications, the bandwidth requirements of the application most likely far surpass the bandwidth consumed by path probes.\r\n\r\nHowever, there's a case to be made that any protocol mechanism that creates state on the peer needs to be limited to protect from DoS attacks. This can either be done explicitly (by setting a limit), or implicitly (by rejecting everything that exceeds a peer-defined limit). #11 suggests a way limit the number of concurrent path validations by using the transport parameter.",
          "createdAt": "2023-10-15T07:29:57Z",
          "updatedAt": "2023-10-15T07:29:57Z"
        }
      ]
    },
    {
      "number": 19,
      "id": "I_kwDOJ5p67M50QIah",
      "title": "Punch me now, but let's keep it safe",
      "url": "https://github.com/marten-seemann/draft-seemann-quic-nat-traversal/issues/19",
      "state": "OPEN",
      "author": "huitema",
      "authorAssociation": "NONE",
      "assignees": [],
      "labels": [],
      "body": "PR #11 introduced the \"Punch me now\" mechanism, as part of bringing the ICE capability inside QUIC. This is great, but we need to beef up the security analysis. As it stands, the client sends a list of \"punch me\" addresses to the server, and the server send probing packets to each address. This can cause a lot of amplification: one packet from the client, as many packets as there are addresses to be punched from the server. It could also cause request spoofing attacks, targeting unrelated services with packets that can be partially predicted by the client.\r\n\r\nI can think of a few mitigations:\r\n\r\n* mitigate request spoofing by making the probing packets somewhat unpredictable. This is a bit hard, because the packets have to include a CID proposed by the client.\r\n* mitigate request spoofing by using the same heuristics used today on client side, such as implement a list of port numbers that will never be punched, check the scope of addresses, etc.\r\n* mitigate amplification by limiting the number of addresses that a server will punch. Consider that if the client sends a new PUNCH ME NOW frame, the previous one is abandoned.\r\n* mitigate amplification by having at most one PUNCH ME NOW frame in a packet. Or maybe limit PUNCH ME NOW to just one address, and just keep act on the last N (3?) PUNCH ME NOW frame received\r\n* mitigate amplification by requiring that PUNCH ME NOW frames be carried in fully padded packets, like \"initial\" or \"challenge\"\r\n* mitigate amplification by allowing servers to send small size probing packets.\r\n\r\nDiscuss?",
      "createdAt": "2023-10-18T18:28:13Z",
      "updatedAt": "2023-10-20T04:29:08Z",
      "closedAt": null,
      "comments": [
        {
          "author": "marten-seemann",
          "authorAssociation": "OWNER",
          "body": "Thanks for opening this issue @huitema! You're right that in the current iteration the details of the amplification protection still need a lot of work.\r\n\r\n> * mitigate request spoofing by making the probing packets somewhat unpredictable. This is a bit hard, because the packets have to include a CID proposed by the client.\r\n\r\nRight. There's a risk of a request forgery attack here, but the risk is a lot smaller than what RFC 9000 section 21.5 describes. The attacker doesn't control more than 20 bytes of the packet (the CID), the size of the packet is set to at least 1200 bytes, all of which (except for the first one) will be indistinguishable from random for a 3rd party.\r\n\r\n\r\n\r\n> * mitigate request spoofing by using the same heuristics used today on client side, such as implement a list of port numbers that will never be punched, check the scope of addresses, etc.\r\n\r\nThis will work in certain scenarios, and break in others. We can list this as a possible mitigation strategy, but I don't think we can require it.\r\n\r\n> * mitigate amplification by limiting the number of addresses that a server will punch. Consider that if the client sends a new PUNCH ME NOW frame, the previous one is abandoned.\r\n> * mitigate amplification by having at most one PUNCH ME NOW frame in a packet. Or maybe limit PUNCH ME NOW to just one address, and just keep act on the last N (3?) PUNCH ME NOW frame received\r\n\r\nLimiting concurrency sounds reasonable, and the protocol provides a mechanism for that: The transport parameter already allows limiting the number of concurrent path probes. We should add some text that this can be used to mitigate the amplification attack as well.\r\n\r\n> * mitigate amplification by requiring that PUNCH ME NOW frames be carried in fully padded packets, like \"initial\" or \"challenge\"\r\n\r\nWe could also reuse the byte counting logic we're using during the handshake: A node is only allowed to send 3x the number of received bytes to unverified addresses (note the plural here). You wouldn't necessarily need to pad the PUNCH_ME_NOW packets, any bytes sent on the connection would suffice.\r\n\r\n> * mitigate amplification by allowing servers to send small size probing packets.\r\n\r\nThis would make people concerned about bandwidth requirements happy. However, it would also mean that you don't verify that the path actually supports QUIC (i.e. UDP datagrams >= 1200 bytes), which seems bad. Maybe a 2-step procedure would help here: First verify connectivity using small probe packets, then confirm that the path supports 1200 bytes. Obviously, this takes one additional roundtrip, which is a tradeoff that might or might not be worthwhile.",
          "createdAt": "2023-10-20T04:29:08Z",
          "updatedAt": "2023-10-20T04:29:08Z"
        }
      ]
    },
    {
      "number": 20,
      "id": "I_kwDOJ5p67M50cBiz",
      "title": "consider allowing probe packets to be smaller than 1200 bytes",
      "url": "https://github.com/marten-seemann/draft-seemann-quic-nat-traversal/issues/20",
      "state": "OPEN",
      "author": "marten-seemann",
      "authorAssociation": "OWNER",
      "assignees": [],
      "labels": [],
      "body": "In #19 @huitema suggested to allow probe packets to be smaller than 1200 bytes.\r\n\r\nThis would drastically reduce the bandwidth requirements for path probes (see also #8). This is especially true since it is expected that a lot of paths probed will not work out, and therefore trigger multiple retransmissions of path probes until a timeout is detected. However, a successful response wouldn't mean that the path is actually usable for QUIC, which has a minimum MTU requirement of 1200 bytes. This might be acceptable in Multipath QUIC, but the consequences are more severe in vanilla QUIC.\r\n\r\nWe could make path validation a 2-step process:\r\n1. Test connectivity using small QUIC packets.\r\n2. Once connectivity has been established, test that the path actually support 1200 bytes.\r\n\r\nThis takes an additional RTT, but for some applications this might be an acceptable tradeoff.",
      "createdAt": "2023-10-20T04:34:40Z",
      "updatedAt": "2023-10-21T18:23:59Z",
      "closedAt": null,
      "comments": [
        {
          "author": "marten-seemann",
          "authorAssociation": "OWNER",
          "body": "The logic could be entirely driven by the client:\r\n* A client MAY send small (smaller than 1200 bytes) probing packets.\r\n* A server MAY respond with a small probing packets, if and only if the client's probe was a small packet. If the client used a full-size (>= 1200 bytes) probing packet, it MUST send a full-size packet in response.\r\n* If the client sent a small probing packet, it MUST confirm that the path supports the minimum MTU by sending a full-size probing packet before initiating migration to that path.",
          "createdAt": "2023-10-20T04:37:08Z",
          "updatedAt": "2023-10-20T04:37:08Z"
        },
        {
          "author": "huitema",
          "authorAssociation": "NONE",
          "body": "To be clear, I was only thinking of allowing the server to send short packets. If I understand correctly, the proposed logic would be:\r\n\r\n1) Client sends \"punch me now\" to the server via the proxy collection\r\n2) In parallel, client sends a probe packet (PATH CHALLENGE) on the desired path (new 4 tuple)\r\n3) Server receives \"punch me now\" and sends a probe packet (PATH CHALLENGE) on the desired path (same new 4 tuple)\r\n4) Hopefully the PATH CHALLENGE of the server has punched a hole in the local NAT, the source address of the server was predicted correctly, and the PATH CHALLENGE from the server reaches the client.\r\n\r\nThis is a bit heavy, because the server will be in fact creating the path. I would prefer something like:\r\n\r\n1) Client sends \"punch me now\" to the server via the proxy collection\r\n2) Server receives \"punch me now\" and sends a probe packet (some new frame) on the desired path (new 4 tuple). Server does not otherwise create any state. Probe opens a pinhole for the path on server side firewall, is not really expected to reach the client. (In a P2P environment, the server may be sitting behind a home firewall.)\r\n3) Some time after \"punch me now\", client sends a probe packet (PATH CHALLENGE) on the desired path (new 4 tuple). If it arrives after the punch but before the pinhole is closed, server receives that, sends PATH Response, etc.\r\n\r\nMaybe that's what you had in mind? In that case, we need to specify what the probe packet is. Shall it contain just a PING, or some new frame \"PUNCHING YOU\", with indication of which \"punch me now\" frame it is responding to? The probe packet could be kept small, of course.\r\n",
          "createdAt": "2023-10-20T06:24:12Z",
          "updatedAt": "2023-10-20T06:24:12Z"
        },
        {
          "author": "marten-seemann",
          "authorAssociation": "OWNER",
          "body": "It was not, but it's an interesting idea. Currently, you're limited by the peer's active_connection_id_limit, which might be significantly smaller than the number of paths that you want to validate at the same time. It would be nice to get around this somehow. Maybe PUNCH_ME_NOW should contain a CID that doesn't count towards that limit, and is _only_ used for the hole punching (the actual path would have to use a regular CID).\r\n\r\nI like the idea of not creating any state, but I'm not sure if that's feasible. Due to its time-dependence, hole punching normally relies on multiple packets being sent. Furthermore, there might be packet loss on the way to your NAT (lossy WiFi, or normal packet loss if you're dealing with a CGNAT), so retransmissions are a necessity here.",
          "createdAt": "2023-10-21T03:56:07Z",
          "updatedAt": "2023-10-21T03:56:07Z"
        },
        {
          "author": "huitema",
          "authorAssociation": "NONE",
          "body": "I think it would be nice to only create state on the client that wants to set up a new path. Have a \"puch me now\" request trigger a stateless response from the server,with enough content to identify which \"punch\" request it is replying to. If more than one message is needed, then the client should repeat the process.\r\n\r\nWith IPv6, simple solutions might suffice. You need to deal with a stateful firewall at each end, but there is no NAT -- or there is a V6 NAT but the mapping is typically stable. In those environment, a simple \"message from client\" opens the pinhole in the stateful firewalls on the client side, and simple message from server opens the pinhole from the server side. So basically:\r\n\r\n1) Client sends a sacrificial probe on the desired path. It opens a pinhole the client-side firewall, but most likely is dropped at the server firewall.\r\n2) Client sends \"punch me now\" through the proxy.\r\n3) Server replies with probe on desired path, does not create state -- one probe per punch, no more. Probes opens a pinhole in server firewall, and if things go as expected it squeezes through the pinhole created by the client's probe in the client's firewall.\r\n4) If the client receives the server's probe, it can proceed with PATH CHALLENGE, etc.\r\n\r\nThe advantage there is \"no CID consumed\". The probes can be tiny, the PMTU will be checked by the path challenge. The cost is one RTT. The optimistic client could send a PATH CHALLENGE just after step 2, but there is a race condition between PATH CHALLENGE and PUNCH ME NOW, so that may fail. The cautious client will just spend one RTT. \r\n\r\nThat scenario will succeed with some IPv4 NAT, but will fail if the server side NAT maps the server probe to an address that the client did not predict (a.k.a. symmetric NAT). In that case, the server's probe will knock on the wrong pinhole. When I was working on Windows, we tried to fix that in a bunch of different ways, which all boil down to trying to predict the port number over which the server's response will arrive. You need a match between:\r\n\r\n1) Client has sent a recent probe with source-ip=Ca, source-port=Cp, dest-ip=Sa, dest-port=Sp,\r\n2) Server's probe appears as dest-ip=Ca', dest-port=Cp', source-ip=Sa', source-port=Sp'\r\n\r\nThe client in most scenarios does have a good idea of Ca and Sa, so we can assume Ca==Ca', Sa==Sa'. The client must predict Cp' and Sp'. The various prediction algorithms that were tried include \"same as before\", \"in sequence\", and \"random\", which lead to different strategies:\r\n\r\nsame as before: ask the server about the addresses that it has seen recently, collect the port numbers, send probes to each of those.\r\nin sequence: assume that if the server has seen port P in use recently, it is likely that the send probes will arrive from one of P+1...P+n. Send client probes to these ports to open as many pin-holes.\r\nrandom: can predict anything. May try the birthday paradox approach, in which each end sends N probes to the peer, with the hope than one pair will match.\r\n\r\nOf course, each probe creates state in the NAT, so sending too many probes risk exhausting the space allocated to mapping tables in the NAT and thus kill existing paths through that NAT.\r\n\r\nBottom line: all these work much better if one of the two ends is open. If you can use PMP or UPNP, or if you can reserve a port number in your home NAT, then do it!",
          "createdAt": "2023-10-21T18:23:59Z",
          "updatedAt": "2023-10-21T18:23:59Z"
        }
      ]
    },
    {
      "number": 21,
      "id": "I_kwDOJ5p67M50cCt2",
      "title": "limit the number of addresses the server can send",
      "url": "https://github.com/marten-seemann/draft-seemann-quic-nat-traversal/issues/21",
      "state": "OPEN",
      "author": "marten-seemann",
      "authorAssociation": "OWNER",
      "assignees": [],
      "labels": [],
      "body": "There's a potential DoS attack if the server sends a large number of ADD_ADDRESS frames. While the client could silently drop addresses above a certain limit, this seems less than ideal. An explicit limit seems preferable, but the current makes this hard to achieve, since there's no ordering between ADD_ADDRESS and REMOVE_ADDRESS frames.",
      "createdAt": "2023-10-20T04:39:52Z",
      "updatedAt": "2023-10-20T04:39:52Z",
      "closedAt": null,
      "comments": []
    },
    {
      "number": 24,
      "id": "I_kwDOJ5p67M50olKF",
      "title": "Add clarity for what's new on the server",
      "url": "https://github.com/marten-seemann/draft-seemann-quic-nat-traversal/issues/24",
      "state": "OPEN",
      "author": "ekinnear",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "> This document introduces the concept of path validation on the server side\r\n\r\nTechnically, the server already validates paths, but we may want to editorially re-word to make it slightly more clear the parts here that are new (NAT bindings, etc. which are covered right after)",
      "createdAt": "2023-10-23T09:59:03Z",
      "updatedAt": "2023-10-23T09:59:03Z",
      "closedAt": null,
      "comments": []
    },
    {
      "number": 28,
      "id": "I_kwDOJ5p67M6F2oA0",
      "title": "Request for Working Example of QUIC with ICE",
      "url": "https://github.com/marten-seemann/draft-seemann-quic-nat-traversal/issues/28",
      "state": "CLOSED",
      "author": "minchopm",
      "authorAssociation": "NONE",
      "assignees": [],
      "labels": [],
      "body": "Hello,\r\n\r\nI've been reviewing your draft on QUIC's ability to traverse NATs using ICE as outlined in the draft-seemann-quic-nat-traversal. The concepts and methods introduced, especially the dual mode of operation\u2014using both a standalone ICE process and a QUIC-based signalling channel\u2014are particularly intriguing.\r\n\r\nI am currently trying to implement these ideas in a practical setting, but I am encountering some challenges in visualizing how the integration works in real-world applications. It would be tremendously helpful if you could provide a working example or a more detailed guide that demonstrates QUIC working in conjunction with ICE for NAT traversal.\r\n\r\nAn example implementation or even pseudocode or real solution would greatly aid in understanding the flow and interactions better, and also help in adopting this technique for projects that might benefit from such a setup.\r\n\r\nThank you for your efforts in creating this draft and for considering this request.\r\n\r\nBest regards,\r\nMincho",
      "createdAt": "2024-04-16T10:25:55Z",
      "updatedAt": "2024-04-16T12:14:52Z",
      "closedAt": "2024-04-16T12:14:51Z",
      "comments": [
        {
          "author": "marten-seemann",
          "authorAssociation": "OWNER",
          "body": "This is the repo of the draft, not an implementation. Feel free to implement one if you\u2019re interested in this.",
          "createdAt": "2024-04-16T12:14:51Z",
          "updatedAt": "2024-04-16T12:14:51Z"
        }
      ]
    },
    {
      "number": 29,
      "id": "I_kwDOJ5p67M6Oh-A8",
      "title": "undefined \"Request Id\" in observed address frames?",
      "url": "https://github.com/marten-seemann/draft-seemann-quic-nat-traversal/issues/29",
      "state": "CLOSED",
      "author": "divagant-martian",
      "authorAssociation": "NONE",
      "assignees": [],
      "labels": [],
      "body": "From reading the proposal I'm under the impression reporting is, let's say, opportunistic:\r\n\r\n> An endpoint that negotiated (see Section 3) this extension and\r\n   offered to provide address observations to the peer MUST send an\r\n   OBSERVED_ADDRESS frame on every new path.  This also applies to the\r\n   path used for the QUIC handshake.\r\n\r\nSimilar parts seem to follow this line of thought. Similarly, there is no frame to request a report in which a potential requester might set this request id. There is also no information about encoding or type. Was this removed at some point, or added missing other parts? Or am I misunderstanding something?",
      "createdAt": "2024-07-04T17:38:32Z",
      "updatedAt": "2024-11-22T19:59:34Z",
      "closedAt": "2024-11-22T19:59:34Z",
      "comments": []
    },
    {
      "number": 30,
      "id": "I_kwDOJ5p67M6TptwO",
      "title": "Compatibility with multipath",
      "url": "https://github.com/marten-seemann/draft-seemann-quic-nat-traversal/issues/30",
      "state": "OPEN",
      "author": "huitema",
      "authorAssociation": "NONE",
      "assignees": [],
      "labels": [],
      "body": "The proposed mechanism is to have server and clients start \"path validation\" simultaneously, using the \"PUNCH_ME_NOW\" frame for synchronization. I assume that the goal is to create a single path.\r\n\r\nThere is no problem doing that with RFC 9000, but there is an issue if the multipath extension is negotiated, because then path creation implies picking a path ID -- i.e., both server and client pick a CID associated with the same path-ID. If they don't, we get two paths.\r\n\r\nThe simplest way to do that would be to add a \"path_id\" element in the PUNCH_ME_NOW frame.\r\n",
      "createdAt": "2024-08-21T06:33:20Z",
      "updatedAt": "2024-08-21T06:34:01Z",
      "closedAt": null,
      "comments": [
        {
          "author": "huitema",
          "authorAssociation": "NONE",
          "body": "Or, we will have to define MP_PUNCH_ME_NOW, but that does not feel right.",
          "createdAt": "2024-08-21T06:34:01Z",
          "updatedAt": "2024-08-21T06:34:01Z"
        }
      ]
    },
    {
      "number": 31,
      "id": "I_kwDOJ5p67M6Tp150",
      "title": "Management of connection ID and rounds",
      "url": "https://github.com/marten-seemann/draft-seemann-quic-nat-traversal/issues/31",
      "state": "OPEN",
      "author": "huitema",
      "authorAssociation": "NONE",
      "assignees": [],
      "labels": [],
      "body": "It seems that servers have two ways to limit the number of ongoing attempts: they can use the \"rounds\" mechanism, or they can control the number of CID provided to the client. The draft is a bit silent about that, merely asking for \"enough CID\".\r\n\r\nIn RFC 9000, the way to get more CID is to retire the unused ones. Logically, that should happen after an attempt is cancelled. Retiring is normally effective after only a \"draining\" timer -- typically 3*RTO, but that's an imperfect mechanism. What happens if a path challenge is delayed and arrives after the CID has been retired? Will that trigger a stateless reset?\r\n\r\nIf we consider the multipath extension, I assume that abandoning an attempt means abandoning the path number used in the attempt. That will be synchronized with the peer (bilateral abandon), and will trigger provisioning of new CID (life is good, if slow).\r\n\r\nIn both cases, there is a pacing mechanism -- there wont be enough resource for new attempts until the RETIRE_CID or PATH_ABANDON have been processed, which include a 3*RTO timer. Given that pacing mechanism, I wonder whether we need to worry with rounds, etc.",
      "createdAt": "2024-08-21T06:53:31Z",
      "updatedAt": "2024-08-21T06:53:31Z",
      "closedAt": null,
      "comments": []
    },
    {
      "number": 33,
      "id": "I_kwDOJ5p67M6cvqef",
      "title": "Should we negotiate ADD_ADDRESS as a separate transport parameter?",
      "url": "https://github.com/marten-seemann/draft-seemann-quic-nat-traversal/issues/33",
      "state": "OPEN",
      "author": "huitema",
      "authorAssociation": "NONE",
      "assignees": [],
      "labels": [],
      "body": "The ADD_ADDRESS frame is required in the NAT Traversal scenario, but it is also useful for \"server initiated path creation\" -- a classic multipath scenario. See for example the issue \"(Should servers be allowed to open new paths)[https://github.com/quicwg/multipath/issues/47]\" in the QUIC Multipath Extension repository. This draft negotiates ADD_ADDRESS and PUNCH_ME_NOW with a single parameter. Supporting one implies supporting the other. That may or may not be the right solution. I anticipate that this point will be raised during adoption discussions in the QUIC WG. It would be good to document the issue in a future version of the draft.\r\n\r\nMost scenarios of  \"server initiated path creation\"  require traversing the client side NAT. This is one of the reasons why this type of path creation was punted to a further version is the QUIC Multipath draft -- or why only the client initiates Path Migration in RFC 9000. We can argue that such path creation also traverses a server side NAT, or at a minimum a server side firewall. If it does, then bundling ADD_ADDRESS and PUNCH_ME_NOW is natural. As an example, servers deployed as Virtual Machines in big servers farms are typically behind a firewall, which will only allow traffic though a few specific port numbers such as 80 or 443. Establishing a path that uses a different port will require firewall traversal.\r\n\r\n",
      "createdAt": "2024-11-01T19:35:03Z",
      "updatedAt": "2024-11-01T19:35:03Z",
      "closedAt": null,
      "comments": []
    },
    {
      "number": 34,
      "id": "I_kwDOJ5p67M6dWmU3",
      "title": "Acknowledge draft-deconinck-multipath-quic-00",
      "url": "https://github.com/marten-seemann/draft-seemann-quic-nat-traversal/issues/34",
      "state": "OPEN",
      "author": "huitema",
      "authorAssociation": "NONE",
      "assignees": [],
      "labels": [],
      "body": "The early [MPQUIC draft](https://datatracker.ietf.org/doc/html/draft-deconinck-multipath-quic-00) published in October 2017 contained the specification of an ADD_ADDRESS Frame sent by server to client so the client could open a path towards the server.",
      "createdAt": "2024-11-07T05:42:45Z",
      "updatedAt": "2024-11-07T05:42:45Z",
      "closedAt": null,
      "comments": []
    },
    {
      "number": 35,
      "id": "I_kwDOJ5p67M6dZbJZ",
      "title": "Can we separate address responder and proxy if needed?",
      "url": "https://github.com/marten-seemann/draft-seemann-quic-nat-traversal/issues/35",
      "state": "OPEN",
      "author": "huitema",
      "authorAssociation": "NONE",
      "assignees": [],
      "labels": [],
      "body": "From the minutes of QUIC at IETF 121:\r\n\r\nAntoine: Is there a way for a proxy inlvolved in address coordination to not be involved in relaying traffic.\r\n\r\nMarten: this would need to be worked out.",
      "createdAt": "2024-11-07T06:06:47Z",
      "updatedAt": "2024-11-07T11:09:23Z",
      "closedAt": null,
      "comments": [
        {
          "author": "marten-seemann",
          "authorAssociation": "OWNER",
          "body": "I understood this as comment regarding the overarching p2p vision, and a request to disentangle the relay used for the coordination channel and the relay used when hole punching fails. This remains to be figured out for the p2p draft.\r\n\r\nTo answer the particular question: any node enabling the address discovery extension is fine. Ideally, we'll end up in a world where major QUIC deployments support this extension.",
          "createdAt": "2024-11-07T11:09:06Z",
          "updatedAt": "2024-11-07T11:09:06Z"
        }
      ]
    }
  ],
  "pulls": [
    {
      "number": 9,
      "id": "PR_kwDOJ5p67M5cXMY2",
      "title": "don't use citations in the abstract",
      "url": "https://github.com/marten-seemann/draft-seemann-quic-nat-traversal/pull/9",
      "state": "MERGED",
      "author": "marten-seemann",
      "authorAssociation": "OWNER",
      "assignees": [],
      "labels": [],
      "body": "Fixes #2.",
      "createdAt": "2023-10-10T10:04:14Z",
      "updatedAt": "2023-10-15T05:09:51Z",
      "baseRepository": "marten-seemann/draft-seemann-quic-nat-traversal",
      "baseRefName": "main",
      "baseRefOid": "22b04d127e4a19d293604ddd6487e7a41bdc2c64",
      "headRepository": "marten-seemann/draft-seemann-quic-nat-traversal",
      "headRefName": "abstract-citations",
      "headRefOid": "379a926b72a10da7a42a0075d8090ec58f0757a4",
      "closedAt": "2023-10-15T05:09:51Z",
      "mergedAt": "2023-10-15T05:09:51Z",
      "mergedBy": "marten-seemann",
      "mergeCommit": {
        "oid": "a643ef81708c89cc565a3f6945cd39f11be75e28"
      },
      "comments": [],
      "reviews": []
    },
    {
      "number": 10,
      "id": "PR_kwDOJ5p67M5c0miR",
      "title": "don't use QUIC bit greasing when demultiplexing ICE",
      "url": "https://github.com/marten-seemann/draft-seemann-quic-nat-traversal/pull/10",
      "state": "MERGED",
      "author": "marten-seemann",
      "authorAssociation": "OWNER",
      "assignees": [],
      "labels": [],
      "body": "",
      "createdAt": "2023-10-15T05:15:48Z",
      "updatedAt": "2023-10-15T05:16:47Z",
      "baseRepository": "marten-seemann/draft-seemann-quic-nat-traversal",
      "baseRefName": "main",
      "baseRefOid": "a643ef81708c89cc565a3f6945cd39f11be75e28",
      "headRepository": "marten-seemann/draft-seemann-quic-nat-traversal",
      "headRefName": "no-quic-bit-greasing",
      "headRefOid": "19ed33e7914bc6ee001a5d5cfb0da17b28454357",
      "closedAt": "2023-10-15T05:16:47Z",
      "mergedAt": "2023-10-15T05:16:47Z",
      "mergedBy": "marten-seemann",
      "mergeCommit": {
        "oid": "858f34db53634a5495fae26d7fb642963a466478"
      },
      "comments": [],
      "reviews": []
    },
    {
      "number": 11,
      "id": "PR_kwDOJ5p67M5c0uJt",
      "title": "absorb ICE into this draft, coordinate NAT traversals from the client",
      "url": "https://github.com/marten-seemann/draft-seemann-quic-nat-traversal/pull/11",
      "state": "MERGED",
      "author": "marten-seemann",
      "authorAssociation": "OWNER",
      "assignees": [],
      "labels": [],
      "body": "Fixes #5. Fixes #6. Fixes #7.",
      "createdAt": "2023-10-15T07:03:52Z",
      "updatedAt": "2023-10-15T07:34:53Z",
      "baseRepository": "marten-seemann/draft-seemann-quic-nat-traversal",
      "baseRefName": "main",
      "baseRefOid": "858f34db53634a5495fae26d7fb642963a466478",
      "headRepository": "marten-seemann/draft-seemann-quic-nat-traversal",
      "headRefName": "replace-ice",
      "headRefOid": "069749f475318fd0df68326541b46783b2dff569",
      "closedAt": "2023-10-15T07:34:53Z",
      "mergedAt": "2023-10-15T07:34:53Z",
      "mergedBy": "marten-seemann",
      "mergeCommit": {
        "oid": "799b4668a527fff51b0c7f305cd5acb337c0aecf"
      },
      "comments": [],
      "reviews": []
    },
    {
      "number": 12,
      "id": "PR_kwDOJ5p67M5dGaoN",
      "title": "improve rendering of frame definitions",
      "url": "https://github.com/marten-seemann/draft-seemann-quic-nat-traversal/pull/12",
      "state": "MERGED",
      "author": "marten-seemann",
      "authorAssociation": "OWNER",
      "assignees": [],
      "labels": [],
      "body": "",
      "createdAt": "2023-10-18T06:41:07Z",
      "updatedAt": "2023-10-18T06:42:55Z",
      "baseRepository": "marten-seemann/draft-seemann-quic-nat-traversal",
      "baseRefName": "main",
      "baseRefOid": "799b4668a527fff51b0c7f305cd5acb337c0aecf",
      "headRepository": "marten-seemann/draft-seemann-quic-nat-traversal",
      "headRefName": "improve-frame-rendering",
      "headRefOid": "33591f1b5278a318124c362657ce40e00574a5e8",
      "closedAt": "2023-10-18T06:42:54Z",
      "mergedAt": "2023-10-18T06:42:54Z",
      "mergedBy": "marten-seemann",
      "mergeCommit": {
        "oid": "21a937ced2f0a03a539c49164b6078aae3f09ea5"
      },
      "comments": [],
      "reviews": []
    },
    {
      "number": 13,
      "id": "PR_kwDOJ5p67M5dHq7Z",
      "title": "improve the introduction",
      "url": "https://github.com/marten-seemann/draft-seemann-quic-nat-traversal/pull/13",
      "state": "MERGED",
      "author": "marten-seemann",
      "authorAssociation": "OWNER",
      "assignees": [],
      "labels": [],
      "body": "",
      "createdAt": "2023-10-18T09:55:49Z",
      "updatedAt": "2023-10-18T10:02:12Z",
      "baseRepository": "marten-seemann/draft-seemann-quic-nat-traversal",
      "baseRefName": "main",
      "baseRefOid": "5e695d1234626e9aedf3e8994f7db6a51d0d8784",
      "headRepository": "marten-seemann/draft-seemann-quic-nat-traversal",
      "headRefName": "improve-introduction",
      "headRefOid": "d2b96a14bb3189e81441294296ba7dbedeaf220d",
      "closedAt": "2023-10-18T10:02:11Z",
      "mergedAt": "2023-10-18T10:02:11Z",
      "mergedBy": "marten-seemann",
      "mergeCommit": {
        "oid": "1c653e566e4040aaf35b7859d936e2ee60b70d3a"
      },
      "comments": [],
      "reviews": []
    },
    {
      "number": 14,
      "id": "PR_kwDOJ5p67M5dHrzb",
      "title": "improve the abstract",
      "url": "https://github.com/marten-seemann/draft-seemann-quic-nat-traversal/pull/14",
      "state": "MERGED",
      "author": "marten-seemann",
      "authorAssociation": "OWNER",
      "assignees": [],
      "labels": [],
      "body": "",
      "createdAt": "2023-10-18T09:57:47Z",
      "updatedAt": "2023-10-18T10:00:16Z",
      "baseRepository": "marten-seemann/draft-seemann-quic-nat-traversal",
      "baseRefName": "main",
      "baseRefOid": "21a937ced2f0a03a539c49164b6078aae3f09ea5",
      "headRepository": "marten-seemann/draft-seemann-quic-nat-traversal",
      "headRefName": "improve-abstract",
      "headRefOid": "46a4a09c7868b123a47854f894761169f00cbe79",
      "closedAt": "2023-10-18T10:00:16Z",
      "mergedAt": "2023-10-18T10:00:16Z",
      "mergedBy": "marten-seemann",
      "mergeCommit": {
        "oid": "5e695d1234626e9aedf3e8994f7db6a51d0d8784"
      },
      "comments": [],
      "reviews": []
    },
    {
      "number": 15,
      "id": "PR_kwDOJ5p67M5dHwof",
      "title": "fix links to other RFCs",
      "url": "https://github.com/marten-seemann/draft-seemann-quic-nat-traversal/pull/15",
      "state": "MERGED",
      "author": "marten-seemann",
      "authorAssociation": "OWNER",
      "assignees": [],
      "labels": [],
      "body": "See https://github.com/quicwg/reliable-stream-reset/pull/31 for motivation.",
      "createdAt": "2023-10-18T10:08:23Z",
      "updatedAt": "2023-10-18T10:09:34Z",
      "baseRepository": "marten-seemann/draft-seemann-quic-nat-traversal",
      "baseRefName": "main",
      "baseRefOid": "1c653e566e4040aaf35b7859d936e2ee60b70d3a",
      "headRepository": "marten-seemann/draft-seemann-quic-nat-traversal",
      "headRefName": "fix-links",
      "headRefOid": "8af3e77372419710de9a31d1ab49d80927de8db3",
      "closedAt": "2023-10-18T10:09:34Z",
      "mergedAt": "2023-10-18T10:09:34Z",
      "mergedBy": "marten-seemann",
      "mergeCommit": {
        "oid": "c953d9e269044b77d003c401cf7805406963bd3c"
      },
      "comments": [],
      "reviews": []
    },
    {
      "number": 16,
      "id": "PR_kwDOJ5p67M5dH8De",
      "title": "move boilerplate after the introduction",
      "url": "https://github.com/marten-seemann/draft-seemann-quic-nat-traversal/pull/16",
      "state": "MERGED",
      "author": "marten-seemann",
      "authorAssociation": "OWNER",
      "assignees": [],
      "labels": [],
      "body": "",
      "createdAt": "2023-10-18T10:36:36Z",
      "updatedAt": "2023-10-18T10:38:22Z",
      "baseRepository": "marten-seemann/draft-seemann-quic-nat-traversal",
      "baseRefName": "main",
      "baseRefOid": "c953d9e269044b77d003c401cf7805406963bd3c",
      "headRepository": "marten-seemann/draft-seemann-quic-nat-traversal",
      "headRefName": "move-boilerplate",
      "headRefOid": "d674762f01f5a8996a844a9adacc65d62f64ae88",
      "closedAt": "2023-10-18T10:38:22Z",
      "mergedAt": "2023-10-18T10:38:22Z",
      "mergedBy": "marten-seemann",
      "mergeCommit": {
        "oid": "f28d5fd74fc7f5aa8588d906d45ae97a55ec2f23"
      },
      "comments": [],
      "reviews": []
    },
    {
      "number": 17,
      "id": "PR_kwDOJ5p67M5dH-pU",
      "title": "add a TODO for IANA considerations",
      "url": "https://github.com/marten-seemann/draft-seemann-quic-nat-traversal/pull/17",
      "state": "MERGED",
      "author": "marten-seemann",
      "authorAssociation": "OWNER",
      "assignees": [],
      "labels": [],
      "body": "",
      "createdAt": "2023-10-18T10:42:19Z",
      "updatedAt": "2023-10-18T10:44:59Z",
      "baseRepository": "marten-seemann/draft-seemann-quic-nat-traversal",
      "baseRefName": "main",
      "baseRefOid": "f28d5fd74fc7f5aa8588d906d45ae97a55ec2f23",
      "headRepository": "marten-seemann/draft-seemann-quic-nat-traversal",
      "headRefName": "iana",
      "headRefOid": "54eac9412fe8b4da5ab34a9dd4b01428a05ca76c",
      "closedAt": "2023-10-18T10:44:59Z",
      "mergedAt": "2023-10-18T10:44:59Z",
      "mergedBy": "marten-seemann",
      "mergeCommit": {
        "oid": "3bfc416810de322a04106e06e1f9f1ab78cc6e7a"
      },
      "comments": [],
      "reviews": []
    },
    {
      "number": 18,
      "id": "PR_kwDOJ5p67M5dIE8u",
      "title": "mention QUIC Multipath",
      "url": "https://github.com/marten-seemann/draft-seemann-quic-nat-traversal/pull/18",
      "state": "MERGED",
      "author": "marten-seemann",
      "authorAssociation": "OWNER",
      "assignees": [],
      "labels": [],
      "body": "",
      "createdAt": "2023-10-18T10:57:03Z",
      "updatedAt": "2023-10-18T10:57:58Z",
      "baseRepository": "marten-seemann/draft-seemann-quic-nat-traversal",
      "baseRefName": "main",
      "baseRefOid": "3bfc416810de322a04106e06e1f9f1ab78cc6e7a",
      "headRepository": "marten-seemann/draft-seemann-quic-nat-traversal",
      "headRefName": "multipath",
      "headRefOid": "d3ee0aeaee6c869f85dd12abaadaff6164bdbfa4",
      "closedAt": "2023-10-18T10:57:58Z",
      "mergedAt": "2023-10-18T10:57:58Z",
      "mergedBy": "marten-seemann",
      "mergeCommit": {
        "oid": "20f96483dcf7c2cae543dddbf307ba89871acdc8"
      },
      "comments": [],
      "reviews": []
    },
    {
      "number": 22,
      "id": "PR_kwDOJ5p67M5de3xN",
      "title": "don't call it modes",
      "url": "https://github.com/marten-seemann/draft-seemann-quic-nat-traversal/pull/22",
      "state": "MERGED",
      "author": "marten-seemann",
      "authorAssociation": "OWNER",
      "assignees": [],
      "labels": [],
      "body": "",
      "createdAt": "2023-10-23T02:54:08Z",
      "updatedAt": "2023-10-23T02:57:23Z",
      "baseRepository": "marten-seemann/draft-seemann-quic-nat-traversal",
      "baseRefName": "main",
      "baseRefOid": "20f96483dcf7c2cae543dddbf307ba89871acdc8",
      "headRepository": "marten-seemann/draft-seemann-quic-nat-traversal",
      "headRefName": "no-modes",
      "headRefOid": "6329b54fafe26ded02c7a62581c1eed88373c162",
      "closedAt": "2023-10-23T02:57:23Z",
      "mergedAt": "2023-10-23T02:57:23Z",
      "mergedBy": "marten-seemann",
      "mergeCommit": {
        "oid": "267727ddbad2822e9e440fa7e5f14fab2c97aeba"
      },
      "comments": [],
      "reviews": []
    },
    {
      "number": 23,
      "id": "PR_kwDOJ5p67M5dfDGq",
      "title": "document interaction with active_connection_id_limit",
      "url": "https://github.com/marten-seemann/draft-seemann-quic-nat-traversal/pull/23",
      "state": "MERGED",
      "author": "marten-seemann",
      "authorAssociation": "OWNER",
      "assignees": [],
      "labels": [],
      "body": "This interaction is quite ugly, and we need to find a better solution here. @huitema listed some ideas in #20.\r\n\r\nHowever, this won't happen before the draft cutoff for Prague (which is later today). Better to document this weird interaction and resolve it in the next iteration of the draft.",
      "createdAt": "2023-10-23T04:04:23Z",
      "updatedAt": "2023-10-23T04:17:17Z",
      "baseRepository": "marten-seemann/draft-seemann-quic-nat-traversal",
      "baseRefName": "main",
      "baseRefOid": "a8f86b0cc64f6a00fcb5fdfe65b383a46b89d7a1",
      "headRepository": "marten-seemann/draft-seemann-quic-nat-traversal",
      "headRefName": "active_connection_id_limit",
      "headRefOid": "7debd6180e27c3cdb1f0513a7d4bd309b12af020",
      "closedAt": "2023-10-23T04:17:17Z",
      "mergedAt": "2023-10-23T04:17:17Z",
      "mergedBy": "marten-seemann",
      "mergeCommit": {
        "oid": "e0a2b014d9b68cbf9de68dfa6cd2b883b09d7a7a"
      },
      "comments": [],
      "reviews": []
    },
    {
      "number": 25,
      "id": "PR_kwDOJ5p67M5dgt4T",
      "title": "Editorial pass, update authors",
      "url": "https://github.com/marten-seemann/draft-seemann-quic-nat-traversal/pull/25",
      "state": "MERGED",
      "author": "ekinnear",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "Editorial pass, update authors\r\n\r\nAlmost entirely little editorial nits, will file issues for more substantial items, etc.",
      "createdAt": "2023-10-23T10:03:47Z",
      "updatedAt": "2023-10-23T21:00:10Z",
      "baseRepository": "marten-seemann/draft-seemann-quic-nat-traversal",
      "baseRefName": "main",
      "baseRefOid": "faaf6a2f5065858185ee366df4e75b315584152b",
      "headRepository": "ekinnear/draft-seemann-quic-nat-traversal",
      "headRefName": "ek/editorial_updates",
      "headRefOid": "b0f399405316e228a29dc5e60f1bc677e97023b8",
      "closedAt": "2023-10-23T21:00:07Z",
      "mergedAt": "2023-10-23T21:00:07Z",
      "mergedBy": "ekinnear",
      "mergeCommit": {
        "oid": "5c1e7d213428399b368c9bb714124988c0da1384"
      },
      "comments": [],
      "reviews": [
        {
          "id": "PRR_kwDOJ5p67M5k3LdR",
          "commit": {
            "abbreviatedOid": "6f9e09a"
          },
          "author": "marten-seemann",
          "authorAssociation": "OWNER",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2023-10-23T10:17:01Z",
          "updatedAt": "2023-10-23T10:19:01Z",
          "comments": [
            {
              "originalPosition": 91,
              "body": "```suggestion\r\nAlthough ICE is not directly used, the logic run on the client makes use of\r\n```",
              "createdAt": "2023-10-23T10:17:01Z",
              "updatedAt": "2023-10-23T10:19:02Z"
            }
          ]
        }
      ]
    },
    {
      "number": 26,
      "id": "PR_kwDOJ5p67M5dk3tJ",
      "title": "Fix whitespace",
      "url": "https://github.com/marten-seemann/draft-seemann-quic-nat-traversal/pull/26",
      "state": "MERGED",
      "author": "ekinnear",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "Fix whitespace",
      "createdAt": "2023-10-23T21:06:21Z",
      "updatedAt": "2023-10-23T22:15:15Z",
      "baseRepository": "marten-seemann/draft-seemann-quic-nat-traversal",
      "baseRefName": "main",
      "baseRefOid": "5c1e7d213428399b368c9bb714124988c0da1384",
      "headRepository": "ekinnear/draft-seemann-quic-nat-traversal",
      "headRefName": "main",
      "headRefOid": "a4d32ad79129676b63f772be5c482a9311d5e68e",
      "closedAt": "2023-10-23T22:15:15Z",
      "mergedAt": "2023-10-23T22:15:15Z",
      "mergedBy": "ekinnear",
      "mergeCommit": {
        "oid": "88bc3434389a59ab4a2f373bf9d668a54972355d"
      },
      "comments": [],
      "reviews": []
    },
    {
      "number": 27,
      "id": "PR_kwDOJ5p67M5nJqHr",
      "title": "remove Marten's affiliation",
      "url": "https://github.com/marten-seemann/draft-seemann-quic-nat-traversal/pull/27",
      "state": "MERGED",
      "author": "marten-seemann",
      "authorAssociation": "OWNER",
      "assignees": [],
      "labels": [],
      "body": "",
      "createdAt": "2024-02-17T03:07:00Z",
      "updatedAt": "2024-02-17T03:07:49Z",
      "baseRepository": "marten-seemann/draft-seemann-quic-nat-traversal",
      "baseRefName": "main",
      "baseRefOid": "88bc3434389a59ab4a2f373bf9d668a54972355d",
      "headRepository": "marten-seemann/draft-seemann-quic-nat-traversal",
      "headRefName": "remove-protocol-labs",
      "headRefOid": "bb72202c3e25860b9762e269888a1d82bdff7a60",
      "closedAt": "2024-02-17T03:07:49Z",
      "mergedAt": "2024-02-17T03:07:49Z",
      "mergedBy": "marten-seemann",
      "mergeCommit": {
        "oid": "f47f871affa08a6b69d6bbfc9abcc086d11dab3d"
      },
      "comments": [],
      "reviews": []
    },
    {
      "number": 32,
      "id": "PR_kwDOJ5p67M6AMHcA",
      "title": "Introduce PUNCH_MY_PATH frame for multipath",
      "url": "https://github.com/marten-seemann/draft-seemann-quic-nat-traversal/pull/32",
      "state": "OPEN",
      "author": "huitema",
      "authorAssociation": "NONE",
      "assignees": [],
      "labels": [],
      "body": "I looked at what if would take to support multipath. I used a new frame for \"PUNCH_ME_NOW + Path ID\", but if we could have a bit in the PUNCH_ME_NOW frame type we would not need that. We would need some explanation about how to use the Path ID, which I added in a subsection of PUNCH_ME_NOW.\r\n\r\nI expect this text to evolve after discussions. But I would like to have these discussions.\r\n\r\nClose #30",
      "createdAt": "2024-10-29T05:36:51Z",
      "updatedAt": "2024-11-01T19:14:21Z",
      "baseRepository": "marten-seemann/draft-seemann-quic-nat-traversal",
      "baseRefName": "main",
      "baseRefOid": "f47f871affa08a6b69d6bbfc9abcc086d11dab3d",
      "headRepository": "huitema/draft-seemann-quic-nat-traversal",
      "headRefName": "punch-my-path",
      "headRefOid": "2fe40f3e9fa50a51ab3ca376fef8eaaf29a3aa28",
      "closedAt": null,
      "mergedAt": null,
      "mergedBy": null,
      "mergeCommit": null,
      "comments": [
        {
          "author": "huitema",
          "authorAssociation": "NONE",
          "body": "Based on @ekinnear comments, I think I should do the clean edit now (tomorrow?), unify PUNCH_MY_PATH and PUNCH_ME_NOW, etc. That would be cleaner.",
          "createdAt": "2024-10-30T07:10:02Z",
          "updatedAt": "2024-10-30T07:10:02Z"
        }
      ],
      "reviews": [
        {
          "id": "PRR_kwDOJ5p67M6PRBF9",
          "commit": {
            "abbreviatedOid": "198df46"
          },
          "author": "ekinnear",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "Probably worth another editorial pass as you noted, but overall seems like a straightforward mapping of the core concepts to multipath -- nice! ",
          "createdAt": "2024-10-30T04:52:37Z",
          "updatedAt": "2024-10-30T04:59:15Z",
          "comments": [
            {
              "originalPosition": 30,
              "body": "Silly nit, is it `Path ID` or `Path-ID`?",
              "createdAt": "2024-10-30T04:52:37Z",
              "updatedAt": "2024-10-30T04:59:15Z"
            },
            {
              "originalPosition": 81,
              "body": "```suggestion\r\n: The Path ID selected by the client for the new path.\r\n```",
              "createdAt": "2024-10-30T04:53:31Z",
              "updatedAt": "2024-10-30T04:59:15Z"
            },
            {
              "originalPosition": 95,
              "body": "It seems reasonable to have the frame have a flag indicating presence of the single additional field. We don't seem them otherwise diverging much in the future, right?",
              "createdAt": "2024-10-30T04:54:16Z",
              "updatedAt": "2024-10-30T04:59:15Z"
            },
            {
              "originalPosition": 49,
              "body": "No objection to helping people do the right thing here, but for my understanding -- this is true of all multipath, no? And we'd note it here because we might be asking people to try more paths than they otherwise would without NAT traversal?",
              "createdAt": "2024-10-30T04:56:41Z",
              "updatedAt": "2024-10-30T04:59:15Z"
            },
            {
              "originalPosition": 41,
              "body": "Wording nit: We can probably reword this to make it more clear, something like you'd have \"as many paths as PUNCH_MY_PATH frames\" or similar.",
              "createdAt": "2024-10-30T04:57:31Z",
              "updatedAt": "2024-10-30T04:59:15Z"
            },
            {
              "originalPosition": 46,
              "body": "```suggestion\r\nWhen the QUIC Multipath extensions have been negotiated, the probing of new\r\n```",
              "createdAt": "2024-10-30T04:57:42Z",
              "updatedAt": "2024-10-30T04:59:15Z"
            },
            {
              "originalPosition": 38,
              "body": "Just to make sure I understand, we're saying: \r\n- If this is a new path, it just brings up a new path, potentially having hole-punched it\r\n- If it's an existing path, please hole-punch it over here, like if we did PUNCH_ME_NOW, but since it's MP-QUIC, just move that path and not everything else",
              "createdAt": "2024-10-30T04:58:45Z",
              "updatedAt": "2024-10-30T04:59:15Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOJ5p67M6PRxck",
          "commit": {
            "abbreviatedOid": "198df46"
          },
          "author": "huitema",
          "authorAssociation": "NONE",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2024-10-30T07:04:51Z",
          "updatedAt": "2024-10-30T07:04:51Z",
          "comments": [
            {
              "originalPosition": 30,
              "body": "The multipath draft uses \"path ID\" throughout.",
              "createdAt": "2024-10-30T07:04:51Z",
              "updatedAt": "2024-10-30T07:04:51Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOJ5p67M6PRzXF",
          "commit": {
            "abbreviatedOid": "198df46"
          },
          "author": "huitema",
          "authorAssociation": "NONE",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2024-10-30T07:06:48Z",
          "updatedAt": "2024-10-30T07:06:49Z",
          "comments": [
            {
              "originalPosition": 49,
              "body": "Yes. Same reason as the blurb on connection ID limits",
              "createdAt": "2024-10-30T07:06:48Z",
              "updatedAt": "2024-10-30T07:06:49Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOJ5p67M6PZz2U",
          "commit": {
            "abbreviatedOid": "198df46"
          },
          "author": "huitema",
          "authorAssociation": "NONE",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2024-10-30T18:26:13Z",
          "updatedAt": "2024-10-30T18:26:13Z",
          "comments": [
            {
              "originalPosition": 95,
              "body": "Yes. That means changing the current provisional allocation of the frame type for PUNCH_ME_NOW.",
              "createdAt": "2024-10-30T18:26:13Z",
              "updatedAt": "2024-10-30T18:26:13Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOJ5p67M6Pj8t6",
          "commit": {
            "abbreviatedOid": "198df46"
          },
          "author": "huitema",
          "authorAssociation": "NONE",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2024-10-31T17:00:06Z",
          "updatedAt": "2024-10-31T17:00:06Z",
          "comments": [
            {
              "originalPosition": 38,
              "body": "I rewrote that part, because the Multipath logic will not normally do path migration. Having a packet arriving with a new tuple on an existing path signals a NAT rebinding. That will trigger a Path Challenge on old and new path, keeping the old path if it is still available, maybe migrating to the new path if it responds sooner. Overall, picking an unused path ID is much cleaner. Even if the desired result is path migration, using a new path ID provides \"make before break\" functionality.",
              "createdAt": "2024-10-31T17:00:06Z",
              "updatedAt": "2024-10-31T17:00:06Z"
            }
          ]
        }
      ]
    }
  ]
}